<!--
  Copyright (c) 2006-2013, JGraph Ltd
  
  Folding example for mxGraph. This example demonstrates
  using a layout to implement a nested group structure.
-->
<html>

<head>
    <title>Hierarchical example for mxGraph</title>

    <style>
        svg text:hover {
            cursor: default;
        }
    </style>

    <!-- Sets the basepath for the library if not in same directory -->
    <script type="text/javascript">
        mxBasePath = 'mxgraph';
        mxLoadResources = false;
    </script>

    <!-- Loads and initializes the library -->
    <script type="text/javascript" src="mxClient.min.js"></script>

    <!-- Example code -->
    <script type="text/javascript">
        var graph;
        // Program starts here. Creates a sample graph in the
        // DOM node with the specified ID. This function is invoked
        // from the onLoad event handler of the document (see below).
        function main(container) {
            // Checks if the browser is supported
            if (!mxClient.isBrowserSupported()) {
                // Displays an error message if the browser is not supported.
                mxUtils.error('Browser is not supported!', 200, false);
            } else {
                // Enables crisp rendering of rectangles in SVG
                mxConstants.ENTITY_SEGMENT = 20;

                // Creates the graph inside the given container
                graph = new mxGraph(container);

                // Disables global features
                graph.collapseToPreferredSize = false;
                graph.constrainChildren = false;
                graph.cellsSelectable = false;
                graph.extendParentsOnAdd = false;
                graph.extendParents = true;
                graph.border = 10;

                var styleEdge = graph.getStylesheet().getDefaultEdgeStyle();
                styleEdge[mxConstants.STYLE_EDGE] = mxEdgeStyle.EntityRelation;
                styleEdge[mxConstants.STYLE_STROKECOLOR] = '#c8c7c7';
                styleEdge[mxConstants.STYLE_STROKEWIDTH] = '2';
                styleEdge[mxConstants.STYLE_ROUNDED] = true;

                var styleCommonCell = graph.getStylesheet().getDefaultVertexStyle();
                styleCommonCell[mxConstants.STYLE_FONTSIZE] = '16';

                var styleColumn = []; //graph.getStylesheet().getDefaultVertexStyle();
                styleColumn[mxConstants.STYLE_FILLCOLOR] = '#e5e5e5';
                styleColumn[mxConstants.STYLE_SWIMLANE_FILLCOLOR] = '#e5e5e5';
                styleColumn[mxConstants.STYLE_SWIMLANE_LINE] = '0';
                styleColumn[mxConstants.STYLE_FONTCOLOR] = '#000000';
                styleColumn[mxConstants.STYLE_STROKECOLOR] = '#c8c7c7';
                styleColumn[mxConstants.STYLE_FONTSIZE] = '16';
                styleColumn[mxConstants.STYLE_SHAPE] = 'swimlane';
                styleColumn[mxConstants.STYLE_STARTSIZE] = 30;
                styleColumn[mxConstants.STYLE_ROUNDED] = true;
                styleColumn[mxConstants.STYLE_FOLDABLE] = false;
                styleColumn[mxConstants.STYLE_FONTSTYLE] = mxConstants.FONT_BOLD;
                graph.getStylesheet().putCellStyle('column', styleColumn);

                var stylePublicGroup = [];
                stylePublicGroup[mxConstants.STYLE_FOLDABLE] = false;
                stylePublicGroup[mxConstants.STYLE_FONTCOLOR] = '#000000';
                stylePublicGroup[mxConstants.STYLE_FILLCOLOR] = '#fff';
                stylePublicGroup[mxConstants.STYLE_SWIMLANE_FILLCOLOR] = '#fff';
                stylePublicGroup[mxConstants.STYLE_FONTSTYLE] = mxConstants.FONT_BOLD;
                stylePublicGroup[mxConstants.STYLE_STROKECOLOR] = '#fff';
                stylePublicGroup[mxConstants.STYLE_SHAPE] = 'swimlane';
                stylePublicGroup[mxConstants.STYLE_ROUNDED] = true;
                graph.getStylesheet().putCellStyle('public', stylePublicGroup);

                var styleVariable = [];
                styleVariable[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_RECTANGLE;
                styleVariable[mxConstants.STYLE_ROUNDED] = true;
                styleVariable[mxConstants.STYLE_FILLCOLOR] = '#6fb4d3';
                styleVariable[mxConstants.STYLE_FONTCOLOR] = '#232323';
                styleVariable[mxConstants.STYLE_STROKECOLOR] = '#6fb4d3';
                graph.getStylesheet().putCellStyle('variable', styleVariable);

                var styleMethod = [];
                styleMethod[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_RECTANGLE;
                styleMethod[mxConstants.STYLE_ROUNDED] = true;
                styleMethod[mxConstants.STYLE_FILLCOLOR] = '#f9bb43';
                styleMethod[mxConstants.STYLE_FONTCOLOR] = '#232323';
                styleMethod[mxConstants.STYLE_STROKECOLOR] = '#f9bb43';
                graph.getStylesheet().putCellStyle('method', styleMethod);

                function updateStyle(state, hover) {
                    if (hover) {
                        if (state.cell.style === 'public') {
                            stylePublicGroup[mxConstants.STYLE_SWIMLANE_FILLCOLOR] = '#fff';
                            state.style[mxConstants.STYLE_STROKECOLOR] = '#fff';
                        } else {
                            state.style[mxConstants.STYLE_STROKECOLOR] = '#707070';
                        }
                    }
                }

                // Changes fill color to red on mouseover
                graph.addMouseListener({
                    currentState: null,
                    previousStyle: null,
                    mouseDown: function (sender, me) {
                        if (this.currentState != null) {
                            this.dragLeave(me.getEvent(), this.currentState);
                            this.currentState = null;
                        }
                    },
                    mouseMove: function (sender, me) {
                        if (this.currentState != null && me.getState() == this.currentState) {
                            return;
                        }

                        var tmp = graph.view.getState(me.getCell());

                        // Ignores everything but vertices
                        if (graph.isMouseDown || (tmp != null && !graph.getModel().isVertex(tmp.cell))) {
                            tmp = null;
                        }

                        if (tmp != this.currentState) {
                            if (this.currentState != null) {
                                this.dragLeave(me.getEvent(), this.currentState);
                            }

                            this.currentState = tmp;

                            if (this.currentState != null) {
                                this.dragEnter(me.getEvent(), this.currentState);
                            }
                        }
                    },
                    mouseUp: function (sender, me) {},
                    dragEnter: function (evt, state) {
                        if (state != null) {
                            this.previousStyle = state.style;
                            state.style = mxUtils.clone(state.style);
                            updateStyle(state, true);
                            state.shape.apply(state);
                            state.shape.redraw();

                            if (state.text != null) {
                                state.text.apply(state);
                                state.text.redraw();
                            }
                        }
                    },
                    dragLeave: function (evt, state) {
                        if (state != null) {
                            state.style = this.previousStyle;
                            updateStyle(state, false);
                            state.shape.apply(state);
                            state.shape.redraw();

                            if (state.text != null) {
                                state.text.apply(state);
                                state.text.redraw();
                            }
                        }
                    }
                });

                graph.addListener(mxEvent.CLICK, function (sender, evt) {
                    var cell = evt.getProperty('cell');

                    if (cell != null) {
                        console.log('click: ', cell);
                    }
                });

                graph.getModel().beginUpdate();
                try {
                    mkGraphWithGroups();
                } finally {
                    graph.getModel().endUpdate();
                    graph.setCellsMovable(false);
                }
            }
        }

        mkGraphWithGroups = () => {
            main = graph.insertVertex(graph.getDefaultParent(), null, 'Main', 0, 0, 200, 200, 'column');
            mainBackup = graph.insertVertex(graph.getDefaultParent(), null, 'MainBackup', 0, 0, 200, 200, 'column');
            game = graph.insertVertex(graph.getDefaultParent(), null, 'Game', 0, 0, 200, 200, 'column');
            player = graph.insertVertex(graph.getDefaultParent(), null, 'Player', 0, 0, 200, 200, 'column');
            rule = graph.insertVertex(graph.getDefaultParent(), null, 'Rule', 0, 0, 30, 200, 'column');

            graph.insertEdge(graph.getDefaultParent(), null, '', main, game);
            graph.insertEdge(graph.getDefaultParent(), null, '', mainBackup, game);
            graph.insertEdge(graph.getDefaultParent(), null, '', game, player);
            graph.insertEdge(graph.getDefaultParent(), null, '', game, rule);


            mainPublic = graph.insertVertex(main, null, 'Public', 0, 0, 80, 30, 'public');
            graph.insertVertex(mainPublic, null, 'game', 0, 0, 60, 30, 'variable');
            graph.insertVertex(mainPublic, null, 'start', 0, 0, 60, 30, 'method');

            var mainPublicG = mainPublic.getGeometry();
            var mainG = main.getGeometry();
            mainG.width = mainPublicG.width + 20;







            playerPublic = graph.insertVertex(player, null, 'Public', 0, 0, 80, 30, 'public');
            graph.insertVertex(playerPublic, null, 'name', 0, 0, 60, 30, 'variable');
            graph.insertVertex(playerPublic, null, 'power', 0, 0, 60, 30, 'variable');
            graph.insertVertex(playerPublic, null, 'weapon', 0, 0, 60, 30, 'variable');
            graph.insertVertex(playerPublic, null, 'type', 0, 0, 60, 30, 'variable');
            graph.insertVertex(playerPublic, null, 'init', 0, 0, 60, 30, 'method');

            var playerPublicG = playerPublic.getGeometry();
            var playerG = player.getGeometry();
            playerG.width = playerPublicG.width + 20;




            gamePublic = graph.insertVertex(game, null, 'Public', 0, 0, 80, 30, 'public');
            graph.insertVertex(gamePublic, null, 'player1', 0, 0, 60, 30, 'variable');
            graph.insertVertex(gamePublic, null, 'player2', 0, 0, 60, 30, 'variable');
            graph.insertVertex(gamePublic, null, 'players', 0, 0, 60, 30, 'variable');
            graph.insertVertex(gamePublic, null, 'morePlayers', 0, 0, 60, 30, 'variable');
            graph.insertVertex(gamePublic, null, 'start', 0, 0, 60, 30, 'method');
            graph.insertVertex(gamePublic, null, 'simpleMethod', 0, 0, 60, 30, 'method');

            var gamePublicG = gamePublic.getGeometry();
            var gameG = game.getGeometry();
            gameG.width = gamePublicG.width + 20;




            rulePublic = graph.insertVertex(rule, null, 'Public', 0, 0, 80, 30, 'public');
            rulePublicSentence = graph.insertVertex(rulePublic, null, 'sentence', 0, 0, 60, 30, 'variable');

            var ruleG = rule.getGeometry();
            var rulePublicG = rulePublic.getGeometry();

            var rulePublicSentenceG = rulePublicSentence.getGeometry();

            var rulePublicSentencePG = graph.getPreferredSizeForCell(rulePublicSentence);

            rulePublicSentenceG.width = rulePublicSentencePG.width + 20;
            rulePublicG.width = rulePublicSentenceG.width + 20;
            ruleG.width = rulePublicG.width + 20;




            layoutGraph(graph.getDefaultParent());

            layoutColumn(mainPublic);
            layoutColumn(main);

            layoutColumn(rulePublic);
            layoutColumn(rule);

            layoutColumn(gamePublic);
            layoutColumn(game);

            layoutColumn(playerPublic);
            layoutColumn(player);

            layoutGraph(graph.getDefaultParent());

            layoutColumn(mainPublic);
            layoutColumn(main);

            layoutColumn(rulePublic);
            layoutColumn(rule);

            layoutColumn(gamePublic);
            layoutColumn(game);

            layoutColumn(playerPublic);
            layoutColumn(player);

            //graph.insertEdge(graph.getDefaultParent(), null, '', gamePublicSentence, playerPublicSentence);
        };

        layoutGraph = objects => {
            layout = new mxHierarchicalLayout(graph, mxConstants.DIRECTION_WEST);

            graph.getModel().beginUpdate();
            try {
                layout.execute(objects);
            } finally {
                graph.getModel().endUpdate();
            }
        };

        layoutColumn = objects => {
            layout = new mxStackLayout(graph, false, 10);
            layout.resizeParent = true;

            layout.marginTop = 10;
            layout.marginRight = 10;
            layout.marginBottom = 10;
            layout.marginLeft = 10;

            graph.getModel().beginUpdate();
            try {
                layout.execute(objects);
            } finally {
                graph.getModel().endUpdate();
            }
        };
    </script>
</head>

<!-- Page passes the container for the graph to the program -->

<body onload="main(document.getElementById('graphContainer'))">
    <!-- Creates a container for the graph with a grid wallpaper -->
    <div id="graphContainer"></div>
</body>

</html>